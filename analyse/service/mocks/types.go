// Code generated by MockGen. DO NOT EDIT.
// Source: analyse/service/types.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	kinesis "github.com/aws/aws-sdk-go-v2/service/kinesis"
	types "github.com/aws/aws-sdk-go-v2/service/kinesis/types"
	gomock "github.com/golang/mock/gomock"
)

// MockAggregator is a mock of Aggregator interface.
type MockAggregator struct {
	ctrl     *gomock.Controller
	recorder *MockAggregatorMockRecorder
}

// MockAggregatorMockRecorder is the mock recorder for MockAggregator.
type MockAggregatorMockRecorder struct {
	mock *MockAggregator
}

// NewMockAggregator creates a new mock instance.
func NewMockAggregator(ctrl *gomock.Controller) *MockAggregator {
	mock := &MockAggregator{ctrl: ctrl}
	mock.recorder = &MockAggregatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregator) EXPECT() *MockAggregatorMockRecorder {
	return m.recorder
}

// Aggregate mocks base method.
func (m *MockAggregator) Aggregate(record *types.Record) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Aggregate", record)
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockAggregatorMockRecorder) Aggregate(record interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*MockAggregator)(nil).Aggregate), record)
}

// Name mocks base method.
func (m *MockAggregator) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockAggregatorMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockAggregator)(nil).Name))
}

// Result mocks base method.
func (m *MockAggregator) Result() interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Result")
	ret0, _ := ret[0].(interface{})
	return ret0
}

// Result indicates an expected call of Result.
func (mr *MockAggregatorMockRecorder) Result() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Result", reflect.TypeOf((*MockAggregator)(nil).Result))
}

// MockKDS is a mock of KDS interface.
type MockKDS struct {
	ctrl     *gomock.Controller
	recorder *MockKDSMockRecorder
}

// MockKDSMockRecorder is the mock recorder for MockKDS.
type MockKDSMockRecorder struct {
	mock *MockKDS
}

// NewMockKDS creates a new mock instance.
func NewMockKDS(ctrl *gomock.Controller) *MockKDS {
	mock := &MockKDS{ctrl: ctrl}
	mock.recorder = &MockKDSMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKDS) EXPECT() *MockKDSMockRecorder {
	return m.recorder
}

// DeregisterStreamConsumer mocks base method.
func (m *MockKDS) DeregisterStreamConsumer(ctx context.Context, params *kinesis.DeregisterStreamConsumerInput, optFns ...func(*kinesis.Options)) (*kinesis.DeregisterStreamConsumerOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeregisterStreamConsumer", varargs...)
	ret0, _ := ret[0].(*kinesis.DeregisterStreamConsumerOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeregisterStreamConsumer indicates an expected call of DeregisterStreamConsumer.
func (mr *MockKDSMockRecorder) DeregisterStreamConsumer(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeregisterStreamConsumer", reflect.TypeOf((*MockKDS)(nil).DeregisterStreamConsumer), varargs...)
}

// DescribeStreamConsumer mocks base method.
func (m *MockKDS) DescribeStreamConsumer(ctx context.Context, params *kinesis.DescribeStreamConsumerInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeStreamConsumerOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribeStreamConsumer", varargs...)
	ret0, _ := ret[0].(*kinesis.DescribeStreamConsumerOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribeStreamConsumer indicates an expected call of DescribeStreamConsumer.
func (mr *MockKDSMockRecorder) DescribeStreamConsumer(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeStreamConsumer", reflect.TypeOf((*MockKDS)(nil).DescribeStreamConsumer), varargs...)
}

// DescribeStreamSummary mocks base method.
func (m *MockKDS) DescribeStreamSummary(ctx context.Context, params *kinesis.DescribeStreamSummaryInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeStreamSummaryOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribeStreamSummary", varargs...)
	ret0, _ := ret[0].(*kinesis.DescribeStreamSummaryOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribeStreamSummary indicates an expected call of DescribeStreamSummary.
func (mr *MockKDSMockRecorder) DescribeStreamSummary(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeStreamSummary", reflect.TypeOf((*MockKDS)(nil).DescribeStreamSummary), varargs...)
}

// ListShards mocks base method.
func (m *MockKDS) ListShards(ctx context.Context, params *kinesis.ListShardsInput, optFns ...func(*kinesis.Options)) (*kinesis.ListShardsOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListShards", varargs...)
	ret0, _ := ret[0].(*kinesis.ListShardsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListShards indicates an expected call of ListShards.
func (mr *MockKDSMockRecorder) ListShards(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListShards", reflect.TypeOf((*MockKDS)(nil).ListShards), varargs...)
}

// RegisterStreamConsumer mocks base method.
func (m *MockKDS) RegisterStreamConsumer(ctx context.Context, params *kinesis.RegisterStreamConsumerInput, optFns ...func(*kinesis.Options)) (*kinesis.RegisterStreamConsumerOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RegisterStreamConsumer", varargs...)
	ret0, _ := ret[0].(*kinesis.RegisterStreamConsumerOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RegisterStreamConsumer indicates an expected call of RegisterStreamConsumer.
func (mr *MockKDSMockRecorder) RegisterStreamConsumer(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterStreamConsumer", reflect.TypeOf((*MockKDS)(nil).RegisterStreamConsumer), varargs...)
}

// SubscribeToShard mocks base method.
func (m *MockKDS) SubscribeToShard(ctx context.Context, params *kinesis.SubscribeToShardInput, optFns ...func(*kinesis.Options)) (*kinesis.SubscribeToShardOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeToShard", varargs...)
	ret0, _ := ret[0].(*kinesis.SubscribeToShardOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubscribeToShard indicates an expected call of SubscribeToShard.
func (mr *MockKDSMockRecorder) SubscribeToShard(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeToShard", reflect.TypeOf((*MockKDS)(nil).SubscribeToShard), varargs...)
}

// MockReporter is a mock of Reporter interface.
type MockReporter struct {
	ctrl     *gomock.Controller
	recorder *MockReporterMockRecorder
}

// MockReporterMockRecorder is the mock recorder for MockReporter.
type MockReporterMockRecorder struct {
	mock *MockReporter
}

// NewMockReporter creates a new mock instance.
func NewMockReporter(ctrl *gomock.Controller) *MockReporter {
	mock := &MockReporter{ctrl: ctrl}
	mock.recorder = &MockReporterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReporter) EXPECT() *MockReporterMockRecorder {
	return m.recorder
}

// Report mocks base method.
func (m *MockReporter) Report(start time.Time, stats map[string]map[string]interface{}, limit int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Report", start, stats, limit)
	ret0, _ := ret[0].(error)
	return ret0
}

// Report indicates an expected call of Report.
func (mr *MockReporterMockRecorder) Report(start, stats, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Report", reflect.TypeOf((*MockReporter)(nil).Report), start, stats, limit)
}

// MockthrottledMetric is a mock of throttledMetric interface.
type MockthrottledMetric struct {
	ctrl     *gomock.Controller
	recorder *MockthrottledMetricMockRecorder
}

// MockthrottledMetricMockRecorder is the mock recorder for MockthrottledMetric.
type MockthrottledMetricMockRecorder struct {
	mock *MockthrottledMetric
}

// NewMockthrottledMetric creates a new mock instance.
func NewMockthrottledMetric(ctrl *gomock.Controller) *MockthrottledMetric {
	mock := &MockthrottledMetric{ctrl: ctrl}
	mock.recorder = &MockthrottledMetricMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockthrottledMetric) EXPECT() *MockthrottledMetricMockRecorder {
	return m.recorder
}

// MaxUtilisation mocks base method.
func (m *MockthrottledMetric) MaxUtilisation() float32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MaxUtilisation")
	ret0, _ := ret[0].(float32)
	return ret0
}

// MaxUtilisation indicates an expected call of MaxUtilisation.
func (mr *MockthrottledMetricMockRecorder) MaxUtilisation() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MaxUtilisation", reflect.TypeOf((*MockthrottledMetric)(nil).MaxUtilisation))
}
